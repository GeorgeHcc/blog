---
title: 网络篇
date: 2023-03-30 22:10:52
permalink: /pages/1323cc/
categories:
  - 面试
tags:
  - 
author: 
  name: GeorgeH
  link: https://github.com/GeorgeHcc 
---







# 一、基础篇

## 1.在浏览器输入网址后发送了什么？

简单来说可分为以下几个步骤

1. ##### 浏览器解析url后，确定了web服务器和文件名，生成http请求信息

2. ##### 解析域名

   1. 浏览器先看自身有没有缓存，如果没有就去看操作系统，操作系统也没有缓存就去看本地hosts文件查看
   2. 如果以上都没有缓存，那么就会去访问本地DNS服务器

3. ##### 操作系统->协议栈

   ###### DNS获取到ip地址后会把http的传输工作委托给操作系统的协议栈

4. ##### TCP

   

   > TCP头部报文中包含源端口、目标端口、包序号（防止包混乱）、确认号、状态位（SYN、SCK、RST、FIN)等。

   > 如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。

   传输数据之前TCP要通过三次握手建立可靠的连接，保证双方都有接收和发送的能力

   在双方建立连接后，生成TCP报文并给http报文添加TCP头部，然后交给下面的网络层处理。

5. ##### 远程定位-IP

   生成IP报文，给数据包加上一层IP头部

   > IP报文头部：源IP地址、目标IP地址

   ###### TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。

6. ##### 两点传输-MAC】

7. 

   生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。

   >  在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

8. ##### 网卡

   将数字信息转换为电信息，将数据发送出去

9. ##### 交换机

   将电信号转换为数字信号，然后根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口，数据包通过交换机转发抵达路由器

10. ##### 路由器

    

11. ##### 服务器



### 



# 二、http篇



## 常见的http状态码

|      | 类别                             | 原因                   |
| ---- | -------------------------------- | ---------------------- |
| 1XX  | information（信息性状态码）      | 接受的请求正在处理     |
| 2XX  | success（成功状态码）            | 请求正常处理成功       |
| 3XX  | redirection（重定向）            | 需要附加操作以完成请求 |
| 4XX  | client error（客户端错误状态码） | 服务器无法处理请求     |
| 5XX  | server error（服务器错误状态码） | 服务器处理请求错误     |

### 2xx成功

-  **200 ok**

   从客户端发起的请求被服务器正常处理

- **201 No Content** **（空内容）**

   该状态码表示服务器正常处理请求，但在返回的响应体中不含实体的主体部分。一般在只需要客户端向服务器发送请求，而不需要对客户端发送新信息的内容的情况下使用

- **206 Partical Content** **（范围请求）**

​		该状态码表示客户端发起范围请求，服务器成功执行了这部分的GET请求。响应报文中包含**Content-Range**指定范围的内容



### 3XX 重定向

- **301 Moved Permanently（永久性重定向）**

  表示请求的资源已被分配了新的URI，如果已经把资源保存书签了，则应该按照Location首部字段提示的URI重新保存

- **302Found 临时重定向** 

  表示请求的资源已分配了新的URI，但是不是永久性的

- **303 See Other**  

  该状态码表示请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源

  303和302有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源。例如使用POST方法发起请求，执行后的处理结果是希望客户端使用GET方法重定向到另一个URI上

- **304 Not Modified** （协商缓存）

  该状态码表示客户端发送<mark>附带条件</mark>的请求时，服务器允许请求访问资源，但未满足条件的情况。

  304状态码返回时，不含任何响应的主体部分，304虽然被划分在3XX类别中，但和重定向没有任何关系。

  ::: note

  附带条件的请求是指采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部。通常表示浏览器协商缓存

  :::

- **307 Temporary Redirect（临时重定向）** 该状态码与302有着相同的含义，尽管302标准禁止POST变成GET，但实际使用时大家并不遵守。307会遵守浏览器标准，不会从POST变为GET



### 4xx 客户端错误

- **400 Bad Request** 表示请求报文中存在语法错误
- **401 unauthorized** 该状态表示发送的请求需要HTTP认证
- **403 Forbidden** 表示请求的资源被服务器拒绝了，通常是没有访问权限
- **404 Not Found** 表示服务器无法找到请求的资源



### 5xx 服务器错误

- **500 Server Error** 

  服务器内部错误，也可能是web应用存在的bug或者某些临时故障

- **503 Server Unavailable** 

  表示服务器暂时处于超负载或者正在停机维护，现在无法处理请求。如果事先得知恢复正常服务的时间，最好写入Retry-After字段在返回给客户端



## http缓存技术

http缓存分为强缓存与协商缓存



### 强缓存



### 协商缓存

**协商缓存就是与服务器协商之后，通过协商结果判断是否使用本地缓存**

协商缓存可以基于两种头部实现

**第一种**：<mark>请求头部</mark>中的 ```If-Modified-Since ``` 字段与<mark>响应头部</mark>中的``` Last-Modified``` 字段



**第二种：** 请求头部中的``` If-None-Match``` 字段与响应头部中的```Etag``` 字段



## http与https的区别

- http是超文本传输协议，是一种<mark>无状态</mark>的协议，采用明文传输（存在安全缺陷）https为了解决这个问题在http网络层与TCP之间加上了SSL/TLS安全协议，使得报文可以加密传输
- http建立连接只需要TCP三次握手，而https还需要进行SSL/TLS的握手过程
- http默认端口是80，https是443
- https需要申请数字证书来保证服务器的身份是可信的

> 什么是无状态协议？每次请求都是独立的，与前面的请求没有任何联系。比如一个应用场景：从**登录->加入购物车->下单->付款**，这几个步骤每一步都需要验证用户的身份信息，而http请求不会把第一次登录的请求的信息用于后面的请求。于是需要我们使用Cookie技术来缓存用户的登录信息



## http/1.1、http/2、http/3的演变

### http/1.1相较于http/1.0提高了什么性能？

**http1.1比较http/1.0性能上的改进：**

- 使用<mark>长连接</mark>的方式改善了http1.0短链接的性能开销
- 支持管道（pipeline）网络传输，<mark>解决请求队头阻塞</mark>只要第一个请求发送出去后不必等待响应就可以继续发送请求

**但是http/1.1还是有瓶颈的：**

- 请求/响应头部未经压缩后就发送
- 头部数据冗余，每次互相发送相同的头部造成很多浪费
- 服务器是按请求数据的顺序响应的，会造成响应对头阻塞
- 没有请求优先级控制
- 请求只能从客户端开始，服务器只能被动响应

### http/2做了什么优化？

**http/2是基于https的，所以安全性是由保障的，相较于http/1.1的改进：**

- **头部压缩** 如果同时发起多个请求，header是一样的或者相识的，那么协议会帮你<mark>消除重复的部分</mark>

  > 这就是所谓的``` HPACK``` 算法:在客户端和服务端同时维护一张头信息表，所有字段都会存入这张表，生成一个索引号，以后就只发送这个索引号就行了

- **二进制格式** http/2全面采用二进制格式（帧）替代纯文本格式，<mark>增加数据传输效率</mark>

- **并发传输** 

- **服务器主动推送资源**



### http3



# webSocket

socket是对传输层的封装，是为了方便使用TCP，UDP而抽象出来的
